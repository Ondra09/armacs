#+TITLE: Eshell
#+AUTHOR: Abraham Raji
#+EMAIL: abrahamraji99@gmail.com
#+STARTUP: overview
#+CREATOR: avronr
#+LANGUAGE: en
#+OPTIONS: num:nil

* Eshell
** Basics
*** Set up the Correct Path
   Need the correct PATH even if we start Emacs from the GUI:
   #+BEGIN_SRC emacs-lisp
     (setenv "PATH"
             (concat
              "/usr/local/bin:/usr/local/sbin:"
              (getenv "PATH")))
   #+END_SRC
*** Pager Setup
   If any program wants to pause the output through the =$PAGER= variable, well
   , we don't really need that:
   #+BEGIN_SRC emacs-lisp
     (setenv "PAGER" "cat")
   #+END_SRC
*** Navigation and Keys

   Eshell comes with some interesting features:
   - ~M-RET~ can be used to accumulate further commands while a command is currently
   running.  Since all input is passed to the subprocess being executed, there is no
   automatic input queueing as there is with other shells.
   - ~C-c C-t~ can be used to truncate the buffer if it grows too large.
   - ~C-c C-r~ will move point to the beginning of the output of the last command.
   With a prefix argument, it will narrow to view only that output.
   - ~C-c C-o~ will delete the output from the last command.
   - ~C-c C-f~ will move forward a complete shell argument.
   - ~C-c C-b~ will move backward a complete shell argument.
** Configuration
Scrolling through the output and searching for results that can be copied to the
 kill ring is a great feature of Eshell. However, instead of running =end-of-buffer
= key-binding, the following setting means any other key will jump back to the prompt:
  #+BEGIN_SRC emacs-lisp
    (use-package eshell
      :init
      (setq ;; eshell-buffer-shorthand t ...  Can't see Bug#19391
            eshell-scroll-to-bottom-on-input 'all
            eshell-error-if-no-glob t
            eshell-hist-ignoredups t
            eshell-save-history-on-exit t
            eshell-prefer-lisp-functions nil
            eshell-destroy-buffer-when-process-dies t))
  #+END_SRC
   I can never seem to remember that =find= and =chmod= behave differently from
   Emacs than their Unix counterparts, so the last setting will prefer the native
   implementations.
** Visual Executables
  Eshell would get somewhat confused if I ran the following commands directly through
  the normal Emacs-Lisp library, as these need the better handling of ansiterm:
  #+BEGIN_SRC emacs-lisp
    (use-package eshell
      :init
      (add-hook 'eshell-mode-hook
                (lambda ()
                  (add-to-list 'eshell-visual-commands "ssh")
                  (add-to-list 'eshell-visual-commands "tail")
                  (add-to-list 'eshell-visual-commands "top"))))
  #+END_SRC
** Aliases
  Gotta have some [[http://www.emacswiki.org/emacs/EshellAlias][shell aliases]], right?
  #+BEGIN_SRC emacs-lisp
      (add-hook 'eshell-mode-hook (lambda ()
          (eshell/alias "e" "find-file $1")
          (eshell/alias "ff" "find-file $1")
          (eshell/alias "emacs" "find-file $1")
          (eshell/alias "ee" "find-file-other-window $1")

          (eshell/alias "gd" "magit-diff-unstaged")
          (eshell/alias "gds" "magit-diff-staged")
          (eshell/alias "d" "dired $1")

          ;; The 'ls' executable requires the Gnu version on the Mac
          (let ((ls (if (file-exists-p "/usr/local/bin/gls")
                        "/usr/local/bin/gls"
                      "/bin/ls")))
            (eshell/alias "ll" (concat ls " -AlohG --color=always")))))
  #+END_SRC
** Git
   My =gst= command is just an alias to =magit-status=, but using the =alias= doesn't
   pull in the current working directory, so I make it a function, instead:
   #+BEGIN_SRC emacs-lisp
     (defun eshell/gst (&rest args)
         (magit-status (pop args) nil)
         (eshell/echo))   ;; The echo command suppresses output
   #+END_SRC
** Find File
   We should have an "f" alias for searching the current directory for a file, and
   a "ef" for editing that file.
   #+BEGIN_SRC emacs-lisp
     (defun eshell/f (filename &optional dir try-count)
       "Searches for files matching FILENAME in either DIR or the
     current directory. Just a typical wrapper around the standard
     `find' executable.

     Since any wildcards in FILENAME need to be escaped, this wraps the shell command.

     If not results were found, it calls the `find' executable up to
     two more times, wrapping the FILENAME pattern in wildcat
     matches. This seems to be more helpful to me."
       (let* ((cmd (concat
                    (executable-find "find")
                    " " (or dir ".")
                    "      -not -path '*/.git*'"
                    " -and -not -path '*node_modules*'"
                    " -and -not -path '*classes*'"
                    " -and "
                    " -type f -and "
                    "-iname '" filename "'"))
              (results (shell-command-to-string cmd)))

         (if (not (s-blank-str? results))
             results
           (cond
            ((or (null try-count) (= 0 try-count))
             (eshell/f (concat filename "*") dir 1))
            ((or (null try-count) (= 1 try-count))
             (eshell/f (concat "*" filename) dir 2))
            (t "")))))

     (defun eshell/ef (filename &optional dir)
       "Searches for the first matching filename and loads it into a
     file to edit."
       (let* ((files (eshell/f filename dir))
              (file (car (s-split "\n" files))))
         (find-file file)))
   #+END_SRC
   Typing =find= in Eshell runs the =find= function, which doesn’t do what I expect
   , and creating an alias is ineffective in overriding it, so a function will do:
   #+BEGIN_SRC emacs-lisp
     (defun eshell/find (&rest args)
       "Wrapper around the ‘find’ executable."
       (let ((cmd (concat "find " (string-join args))))
         (shell-command-to-string cmd)))
   #+END_SRC
** Clear
   While deleting and recreating =eshell= may be just as fast, I always
   forget and type =clear=, so let's implement it:

   #+BEGIN_SRC emacs-lisp
     (defun eshell/clear ()
       "Clear the eshell buffer."
       (let ((inhibit-read-only t))
         (erase-buffer)
         (eshell-send-input)))
   #+END_SRC
